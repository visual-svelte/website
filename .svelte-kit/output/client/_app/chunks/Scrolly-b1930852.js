import{S as A,i as B,s as C,_ as D,e as T,c as X,a as Y,d as y,g as Z,X as j,Y as z,Z as F,q as G,o as H,v as J,a5 as K}from"./vendor-a43dc3a5.js";function L(l){let n,o;const a=l[7].default,s=D(a,l,l[6],null);return{c(){n=T("div"),s&&s.c()},l(e){n=X(e,"DIV",{});var i=Y(n);s&&s.l(i),i.forEach(y)},m(e,i){Z(e,n,i),s&&s.m(n,null),l[8](n),o=!0},p(e,[i]){s&&s.p&&(!o||i&64)&&j(s,a,e,e[6],o?F(a,e[6],i,null):z(e[6]),null)},i(e){o||(G(s,e),o=!0)},o(e){H(s,e),o=!1},d(e){e&&y(n),s&&s.d(e),l[8](null)}}}function N(l,n,o){let{$$slots:a={},$$scope:s}=n,{root:e=null}=n,{top:i=0}=n,{bottom:u=0}=n,{increments:f=100}=n,{value:m=0}=n;const _=[],g=[];let h=[],b=[],d;const v=()=>{!h.length||h.forEach(O)},q=()=>{let t=0,r=0;for(let c=0;c<_.length;c++)_[c]>t&&(t=_[c],r=c);t>0?o(1,m=r):o(1,m=0)},O=(t,r)=>{const c=S=>{S[0].isIntersecting;const k=S[0].intersectionRatio;_[r]=k,q()},E=i?i*-1:0,M=u?u*-1:0,R=`${E}px 0px ${M}px 0px`,V={root:e,rootMargin:R,threshold:g};b[r]&&b[r].disconnect();const I=new IntersectionObserver(c,V);I.observe(t),b[r]=I};J(()=>{for(let t=0;t<f+1;t++)g.push(t/f);h=d.querySelectorAll(":scope > *"),v()});function w(t){K[t?"unshift":"push"](()=>{d=t,o(0,d)})}return l.$$set=t=>{"root"in t&&o(2,e=t.root),"top"in t&&o(3,i=t.top),"bottom"in t&&o(4,u=t.bottom),"increments"in t&&o(5,f=t.increments),"value"in t&&o(1,m=t.value),"$$scope"in t&&o(6,s=t.$$scope)},l.$$.update=()=>{l.$$.dirty&24&&v()},[d,m,e,i,u,f,s,a,w]}class Q extends A{constructor(n){super();B(this,n,N,L,C,{root:2,top:3,bottom:4,increments:5,value:1})}}export{Q as S};
