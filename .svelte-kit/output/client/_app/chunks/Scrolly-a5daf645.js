import{S as A,i as B,s as C,Z as D,e as T,c as W,a as X,d as y,g as Y,W as Z,X as j,Y as z,q as F,o as G,v as H,a7 as J}from"./vendor-36416740.js";function K(l){let n,o;const a=l[7].default,s=D(a,l,l[6],null);return{c(){n=T("div"),s&&s.c()},l(e){n=W(e,"DIV",{});var i=X(n);s&&s.l(i),i.forEach(y)},m(e,i){Y(e,n,i),s&&s.m(n,null),l[8](n),o=!0},p(e,[i]){s&&s.p&&(!o||i&64)&&Z(s,a,e,e[6],o?z(a,e[6],i,null):j(e[6]),null)},i(e){o||(F(s,e),o=!0)},o(e){G(s,e),o=!1},d(e){e&&y(n),s&&s.d(e),l[8](null)}}}function L(l,n,o){let{$$slots:a={},$$scope:s}=n,{root:e=null}=n,{top:i=0}=n,{bottom:u=0}=n,{increments:f=100}=n,{value:m=0}=n;const _=[],g=[];let h=[],b=[],d;const v=()=>{!h.length||h.forEach(O)},q=()=>{let t=0,r=0;for(let c=0;c<_.length;c++)_[c]>t&&(t=_[c],r=c);t>0?o(1,m=r):o(1,m=0)},O=(t,r)=>{const c=S=>{S[0].isIntersecting;const k=S[0].intersectionRatio;_[r]=k,q()},E=i?i*-1:0,M=u?u*-1:0,R=`${E}px 0px ${M}px 0px`,V={root:e,rootMargin:R,threshold:g};b[r]&&b[r].disconnect();const I=new IntersectionObserver(c,V);I.observe(t),b[r]=I};H(()=>{for(let t=0;t<f+1;t++)g.push(t/f);h=d.querySelectorAll(":scope > *"),v()});function w(t){J[t?"unshift":"push"](()=>{d=t,o(0,d)})}return l.$$set=t=>{"root"in t&&o(2,e=t.root),"top"in t&&o(3,i=t.top),"bottom"in t&&o(4,u=t.bottom),"increments"in t&&o(5,f=t.increments),"value"in t&&o(1,m=t.value),"$$scope"in t&&o(6,s=t.$$scope)},l.$$.update=()=>{l.$$.dirty&24&&v()},[d,m,e,i,u,f,s,a,w]}class P extends A{constructor(n){super();B(this,n,L,K,C,{root:2,top:3,bottom:4,increments:5,value:1})}}export{P as S};
