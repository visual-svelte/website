"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printReceivedStringContainExpectedSubstring = exports.printReceivedStringContainExpectedResult = exports.expect = void 0;

var _expect = _interopRequireDefault(require("expect"));

var _path = _interopRequireDefault(require("path"));

var _jestMatcherUtils = require("jest-matcher-utils");

var _matchers = require("./matchers/matchers");

var _toMatchSnapshot = require("./matchers/toMatchSnapshot");

var _matchers2 = _interopRequireDefault(require("expect/build/matchers"));

var _globals = require("./globals");

var _util = require("./util");

var _stackUtils = _interopRequireDefault(require("stack-utils"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stackUtils = new _stackUtils.default(); // #region
// Mirrored from https://github.com/facebook/jest/blob/f13abff8df9a0e1148baf3584bcde6d1b479edc7/packages/expect/src/print.ts

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found here
 * https://github.com/facebook/jest/blob/1547740bbc26400d69f4576bf35645163e942829/LICENSE
 */
// Format substring but do not enclose in double quote marks.
// The replacement is compatible with pretty-format package.

const printSubstring = val => val.replace(/"|\\/g, '\\$&');

const printReceivedStringContainExpectedSubstring = (received, start, length // not end
) => (0, _jestMatcherUtils.RECEIVED_COLOR)('"' + printSubstring(received.slice(0, start)) + (0, _jestMatcherUtils.INVERTED_COLOR)(printSubstring(received.slice(start, start + length))) + printSubstring(received.slice(start + length)) + '"');

exports.printReceivedStringContainExpectedSubstring = printReceivedStringContainExpectedSubstring;

const printReceivedStringContainExpectedResult = (received, result) => result === null ? (0, _jestMatcherUtils.printReceived)(received) : printReceivedStringContainExpectedSubstring(received, result.index, result[0].length); // #endregion


exports.printReceivedStringContainExpectedResult = printReceivedStringContainExpectedResult;

function createExpect(actual, message, isSoft) {
  if (message !== undefined && typeof message !== 'string') throw new Error('expect(actual, optionalErrorMessage): optional error message must be a string.');
  return new Proxy((0, _expect.default)(actual), new ExpectMetaInfoProxyHandler(message || '', isSoft));
}

const expect = new Proxy(_expect.default, {
  apply: function (target, thisArg, argumentsList) {
    const [actual, message] = argumentsList;
    return createExpect(actual, message, false
    /* isSoft */
    );
  }
});
exports.expect = expect;

expect.soft = (actual, message) => {
  return createExpect(actual, message, true
  /* isSoft */
  );
};

_expect.default.setState({
  expand: false
});

const customMatchers = {
  toBeChecked: _matchers.toBeChecked,
  toBeDisabled: _matchers.toBeDisabled,
  toBeEditable: _matchers.toBeEditable,
  toBeEmpty: _matchers.toBeEmpty,
  toBeEnabled: _matchers.toBeEnabled,
  toBeFocused: _matchers.toBeFocused,
  toBeHidden: _matchers.toBeHidden,
  toBeOK: _matchers.toBeOK,
  toBeVisible: _matchers.toBeVisible,
  toContainText: _matchers.toContainText,
  toHaveAttribute: _matchers.toHaveAttribute,
  toHaveClass: _matchers.toHaveClass,
  toHaveCount: _matchers.toHaveCount,
  toHaveCSS: _matchers.toHaveCSS,
  toHaveId: _matchers.toHaveId,
  toHaveJSProperty: _matchers.toHaveJSProperty,
  toHaveText: _matchers.toHaveText,
  toHaveTitle: _matchers.toHaveTitle,
  toHaveURL: _matchers.toHaveURL,
  toHaveValue: _matchers.toHaveValue,
  toMatchSnapshot: _toMatchSnapshot.toMatchSnapshot
};
let expectCallMetaInfo = undefined;

class ExpectMetaInfoProxyHandler {
  constructor(message, isSoft) {
    this._message = void 0;
    this._isSoft = void 0;
    this._message = message;
    this._isSoft = isSoft;
  }

  get(target, prop, receiver) {
    const value = Reflect.get(target, prop, receiver);
    if (typeof value !== 'function') return new Proxy(value, this);
    return (...args) => {
      const testInfo = (0, _globals.currentTestInfo)();
      if (!testInfo) return value.call(target, ...args);

      const handleError = e => {
        if (this._isSoft) testInfo._failWithError((0, _util.serializeError)(e), false
        /* isHardError */
        );else throw e;
      };

      try {
        expectCallMetaInfo = {
          message: this._message,
          isSoft: this._isSoft
        };
        let result = value.call(target, ...args);
        if (result instanceof Promise) result = result.catch(handleError);
        return result;
      } catch (e) {
        handleError(e);
      } finally {
        expectCallMetaInfo = undefined;
      }
    };
  }

}

function wrap(matcherName, matcher) {
  const result = function (...args) {
    var _expectCallMetaInfo$m, _expectCallMetaInfo, _expectCallMetaInfo$i, _expectCallMetaInfo2;

    const testInfo = (0, _globals.currentTestInfo)();
    if (!testInfo) return matcher.call(this, ...args);
    const INTERNAL_STACK_LENGTH = 4; // at Object.__PWTRAP__[expect.toHaveText] (...)
    // at __EXTERNAL_MATCHER_TRAP__ (...)
    // at Object.throwingMatcher [as toHaveText] (...)
    // at Proxy.<anonymous>
    // at <test function> (...)

    const stackLines = new Error().stack.split('\n').slice(INTERNAL_STACK_LENGTH + 1);
    const frame = stackLines[0] ? stackUtils.parseLine(stackLines[0]) : undefined;
    const customMessage = (_expectCallMetaInfo$m = (_expectCallMetaInfo = expectCallMetaInfo) === null || _expectCallMetaInfo === void 0 ? void 0 : _expectCallMetaInfo.message) !== null && _expectCallMetaInfo$m !== void 0 ? _expectCallMetaInfo$m : '';
    const isSoft = (_expectCallMetaInfo$i = (_expectCallMetaInfo2 = expectCallMetaInfo) === null || _expectCallMetaInfo2 === void 0 ? void 0 : _expectCallMetaInfo2.isSoft) !== null && _expectCallMetaInfo$i !== void 0 ? _expectCallMetaInfo$i : false;

    const step = testInfo._addStep({
      location: frame && frame.file ? {
        file: _path.default.resolve(process.cwd(), frame.file),
        line: frame.line || 0,
        column: frame.column || 0
      } : undefined,
      category: 'expect',
      title: customMessage || `expect${isSoft ? '.soft' : ''}${this.isNot ? '.not' : ''}.${matcherName}`,
      canHaveChildren: true,
      forceNoParent: false
    });

    const reportStepEnd = result => {
      const success = result.pass !== this.isNot;
      let error;

      if (!success) {
        const message = result.message();
        error = {
          message,
          stack: message + '\n' + stackLines.join('\n')
        };

        if (customMessage) {
          const messageLines = message.split('\n'); // Jest adds something like the following error to all errors:
          //    expect(received).toBe(expected); // Object.is equality

          const uselessMatcherLineIndex = messageLines.findIndex(line => /expect.*\(.*received.*\)/.test(line));

          if (uselessMatcherLineIndex !== -1) {
            // if there's a newline after the matcher text, then remove it as well.
            if (uselessMatcherLineIndex + 1 < messageLines.length && messageLines[uselessMatcherLineIndex + 1].trim() === '') messageLines.splice(uselessMatcherLineIndex, 2);else messageLines.splice(uselessMatcherLineIndex, 1);
          }

          const newMessage = [customMessage, '', ...messageLines].join('\n');

          result.message = () => newMessage;
        }
      }

      step.complete(error);
      return result;
    };

    const reportStepError = error => {
      step.complete((0, _util.serializeError)(error));
      throw error;
    };

    try {
      const result = matcher.call(this, ...args);
      if (result instanceof Promise) return result.then(reportStepEnd).catch(reportStepError);
      return reportStepEnd(result);
    } catch (e) {
      reportStepError(e);
    }
  };

  Object.defineProperty(result, 'name', {
    value: '__PWTRAP__[expect.' + matcherName + ']'
  });
  return result;
}

const wrappedMatchers = {};

for (const matcherName in _matchers2.default) wrappedMatchers[matcherName] = wrap(matcherName, _matchers2.default[matcherName]);

for (const matcherName in customMatchers) wrappedMatchers[matcherName] = wrap(matcherName, customMatchers[matcherName]);

_expect.default.extend(wrappedMatchers);