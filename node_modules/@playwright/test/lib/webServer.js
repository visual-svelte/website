"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebServer = void 0;

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _net = _interopRequireDefault(require("net"));

var _os = _interopRequireDefault(require("os"));

var _stream = _interopRequireDefault(require("stream"));

var _debug = _interopRequireDefault(require("debug"));

var _async = require("playwright-core/lib/utils/async");

var _processLauncher = require("playwright-core/lib/utils/processLauncher");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENVIRONMENT_VARIABLES = {
  'BROWSER': 'none' // Disable that create-react-app will open the page in the browser

};

const newProcessLogPrefixer = () => new _stream.default.Transform({
  transform(chunk, encoding, callback) {
    this.push(chunk.toString().split(_os.default.EOL).map(line => line ? `[WebServer] ${line}` : line).join(_os.default.EOL));
    callback();
  }

});

const debugWebServer = (0, _debug.default)('pw:webserver');

class WebServer {
  constructor(config) {
    this._isAvailable = void 0;
    this._killProcess = void 0;
    this._processExitedPromise = void 0;
    this.config = config;
    this._isAvailable = getIsAvailableFunction(config);
  }

  static async create(config) {
    const webServer = new WebServer(config);

    try {
      await webServer._startProcess();
      await webServer._waitForProcess();
      return webServer;
    } catch (error) {
      await webServer.kill();
      throw error;
    }
  }

  async _startProcess() {
    let processExitedReject = error => {};

    this._processExitedPromise = new Promise((_, reject) => processExitedReject = reject);
    const isAlreadyAvailable = await this._isAvailable();

    if (isAlreadyAvailable) {
      var _this$config$url;

      if (this.config.reuseExistingServer) return;
      throw new Error(`${(_this$config$url = this.config.url) !== null && _this$config$url !== void 0 ? _this$config$url : `http://localhost:${this.config.port}`} is already used, make sure that nothing is running on the port/url or set strict:false in config.webServer.`);
    }

    const {
      launchedProcess,
      kill
    } = await (0, _processLauncher.launchProcess)({
      command: this.config.command,
      env: { ...DEFAULT_ENVIRONMENT_VARIABLES,
        ...process.env,
        ...this.config.env
      },
      cwd: this.config.cwd,
      stdio: 'stdin',
      shell: true,
      attemptToGracefullyClose: async () => {},
      log: () => {},
      onExit: code => processExitedReject(new Error(`Process from config.webServer was not able to start. Exit code: ${code}`)),
      tempDirectories: []
    });
    this._killProcess = kill;
    launchedProcess.stderr.pipe(newProcessLogPrefixer()).pipe(process.stderr);
    launchedProcess.stdout.on('data', line => debugWebServer(line.toString()));
  }

  async _waitForProcess() {
    await this._waitForAvailability();
    if (this.config.port !== undefined) process.env.PLAYWRIGHT_TEST_BASE_URL = `http://localhost:${this.config.port}`;
  }

  async _waitForAvailability() {
    const launchTimeout = this.config.timeout || 60 * 1000;
    const cancellationToken = {
      canceled: false
    };
    const {
      timedOut
    } = await Promise.race([(0, _async.raceAgainstTimeout)(() => waitFor(this._isAvailable, 100, cancellationToken), launchTimeout), this._processExitedPromise]);
    cancellationToken.canceled = true;
    if (timedOut) throw new Error(`Timed out waiting ${launchTimeout}ms from config.webServer.`);
  }

  async kill() {
    var _this$_killProcess;

    await ((_this$_killProcess = this._killProcess) === null || _this$_killProcess === void 0 ? void 0 : _this$_killProcess.call(this));
  }

}

exports.WebServer = WebServer;

async function isPortUsed(port) {
  const innerIsPortUsed = host => new Promise(resolve => {
    const conn = _net.default.connect(port, host).on('error', () => {
      resolve(false);
    }).on('connect', () => {
      conn.end();
      resolve(true);
    });
  });

  return (await innerIsPortUsed('127.0.0.1')) || (await innerIsPortUsed('::1'));
}

async function isURLAvailable(url) {
  return new Promise(resolve => {
    (url.protocol === 'https:' ? _https.default : _http.default).get(url, res => {
      var _res$statusCode;

      res.resume();
      const statusCode = (_res$statusCode = res.statusCode) !== null && _res$statusCode !== void 0 ? _res$statusCode : 0;
      resolve(statusCode >= 200 && statusCode < 300);
    }).on('error', () => {
      resolve(false);
    });
  });
}

async function waitFor(waitFn, delay, cancellationToken) {
  while (!cancellationToken.canceled) {
    const connected = await waitFn();
    if (connected) return;
    await new Promise(x => setTimeout(x, delay));
  }
}

function getIsAvailableFunction({
  url,
  port
}) {
  if (url !== undefined && port === undefined) {
    const urlObject = new URL(url);
    return () => isURLAvailable(urlObject);
  } else if (port !== undefined && url === undefined) {
    return () => isPortUsed(port);
  } else {
    throw new Error(`Exactly one of 'port' or 'url' is required in config.webServer.`);
  }
}