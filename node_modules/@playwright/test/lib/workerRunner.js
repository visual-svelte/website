"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerRunner = void 0;

var _rimraf = _interopRequireDefault(require("rimraf"));

var _util = _interopRequireDefault(require("util"));

var _safe = _interopRequireDefault(require("colors/safe"));

var _events = require("events");

var _util2 = require("./util");

var _globals = require("./globals");

var _loader = require("./loader");

var _test = require("./test");

var _fixtures = require("./fixtures");

var _async = require("playwright-core/lib/utils/async");

var _testInfo = require("./testInfo");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const removeFolderAsync = _util.default.promisify(_rimraf.default);

class WorkerRunner extends _events.EventEmitter {
  constructor(params) {
    super();
    this._params = void 0;
    this._loader = void 0;
    this._project = void 0;
    this._workerInfo = void 0;
    this._fixtureRunner = void 0;
    this._failedTest = void 0;
    this._fatalError = void 0;
    this._entries = new Map();
    this._isStopped = false;
    this._runFinished = Promise.resolve();
    this._currentTest = null;
    this._params = params;
    this._fixtureRunner = new _fixtures.FixtureRunner();
  }

  stop() {
    if (!this._isStopped) {
      var _this$_currentTest;

      this._isStopped = true; // Interrupt current action.

      (_this$_currentTest = this._currentTest) === null || _this$_currentTest === void 0 ? void 0 : _this$_currentTest._timeoutRunner.interrupt(); // TODO: mark test as 'interrupted' instead.

      if (this._currentTest && this._currentTest.status === 'passed') this._currentTest.status = 'skipped';
    }

    return this._runFinished;
  }

  async cleanup() {
    // We have to load the project to get the right deadline below.
    await this._loadIfNeeded();
    await this._teardownScopes();
    if (this._fatalError) this.emit('teardownError', {
      error: this._fatalError
    });
  }

  async _teardownScopes() {
    // TODO: separate timeout for teardown?
    const result = await (0, _async.raceAgainstTimeout)(async () => {
      await this._fixtureRunner.teardownScope('test');
      await this._fixtureRunner.teardownScope('worker');
    }, this._project.config.timeout);
    if (result.timedOut && !this._fatalError) this._fatalError = {
      message: _safe.default.red(`Timeout of ${this._project.config.timeout}ms exceeded while shutting down environment`)
    };
  }

  unhandledError(error) {
    var _this$_currentTest2;

    // Usually, we do not differentiate between errors in the control flow
    // and unhandled errors - both lead to the test failing. This is good for regular tests,
    // so that you can, e.g. expect() from inside an event handler. The test fails,
    // and we restart the worker.
    //
    // However, for tests marked with test.fail(), this is a problem. Unhandled error
    // could come either from the user test code (legit failure), or from a fixture or
    // a test runner. In the latter case, the worker state could be messed up,
    // and continuing to run tests in the same worker is problematic. Therefore,
    // we turn this into a fatal error and restart the worker anyway.
    // The only exception is the expect() error that we still consider ok.
    const isExpectError = error instanceof Error && !!error.matcherResult;
    const isCurrentTestExpectedToFail = ((_this$_currentTest2 = this._currentTest) === null || _this$_currentTest2 === void 0 ? void 0 : _this$_currentTest2.expectedStatus) === 'failed';
    const shouldConsiderAsTestError = isExpectError || !isCurrentTestExpectedToFail;

    if (this._currentTest && this._currentTest._test._type === 'test' && shouldConsiderAsTestError) {
      this._currentTest._failWithError((0, _util2.serializeError)(error), true
      /* isHardError */
      );
    } else {
      // No current test - fatal error.
      if (!this._fatalError) this._fatalError = (0, _util2.serializeError)(error);
    }

    this.stop();
  }

  async _loadIfNeeded() {
    if (this._loader) return;
    this._loader = await _loader.Loader.deserialize(this._params.loader);
    this._project = this._loader.projects()[this._params.projectIndex];
    this._workerInfo = {
      workerIndex: this._params.workerIndex,
      parallelIndex: this._params.parallelIndex,
      project: this._project.config,
      config: this._loader.fullConfig()
    };
  }

  async run(runPayload) {
    let runFinishedCallback = () => {};

    this._runFinished = new Promise(f => runFinishedCallback = f);

    try {
      this._entries = new Map(runPayload.entries.map(e => [e.testId, e]));
      await this._loadIfNeeded();
      const fileSuite = await this._loader.loadTestFile(runPayload.file, 'worker');

      const suite = this._project.cloneFileSuite(fileSuite, this._params.repeatEachIndex, test => {
        if (!this._entries.has(test._id)) return false;
        return true;
      });

      if (suite) {
        const firstPool = suite.allTests()[0]._pool;

        this._fixtureRunner.setPool(firstPool);

        await this._runSuite(suite, []);
      }

      if (this._failedTest) await this._teardownScopes();
    } catch (e) {
      // In theory, we should run above code without any errors.
      // However, in the case we screwed up, or loadTestFile failed in the worker
      // but not in the runner, let's do a fatal error.
      this.unhandledError(e);
    } finally {
      if (this._failedTest) {
        // Now that we did run all hooks and teared down scopes, we can
        // report the failure, possibly with any error details revealed by teardown.
        this.emit('testEnd', buildTestEndPayload(this._failedTest));
      }

      this._reportDone();

      runFinishedCallback();
    }
  }

  async _runSuite(suite, annotations) {
    // When stopped, do not run a suite. But if we have started running the suite with hooks,
    // always finish the hooks.
    if (this._isStopped) return;
    annotations = annotations.concat(suite._annotations);

    for (const beforeAllModifier of suite._modifiers) {
      if (!this._fixtureRunner.dependsOnWorkerFixturesOnly(beforeAllModifier.fn, beforeAllModifier.location)) continue; // TODO: separate timeout for beforeAll modifiers?

      const result = await (0, _async.raceAgainstTimeout)(() => this._fixtureRunner.resolveParametersAndRunFunction(beforeAllModifier.fn, this._workerInfo, undefined), this._project.config.timeout);

      if (result.timedOut) {
        if (!this._fatalError) this._fatalError = (0, _util2.serializeError)(new Error(`Timeout of ${this._project.config.timeout}ms exceeded while running ${beforeAllModifier.type} modifier\n    at ${(0, _util2.formatLocation)(beforeAllModifier.location)}`));
        this.stop();
      } else if (!!result.result) {
        annotations.push({
          type: beforeAllModifier.type,
          description: beforeAllModifier.description
        });
      }
    }

    for (const hook of suite.hooks) {
      var _this$_entries$get;

      if (hook._type !== 'beforeAll') continue;
      const firstTest = suite.allTests()[0];
      await this._runTestOrAllHook(hook, annotations, ((_this$_entries$get = this._entries.get(firstTest._id)) === null || _this$_entries$get === void 0 ? void 0 : _this$_entries$get.retry) || 0);
    }

    for (const entry of suite._entries) {
      if (entry instanceof _test.Suite) {
        await this._runSuite(entry, annotations);
      } else {
        const runEntry = this._entries.get(entry._id);

        if (runEntry && !this._isStopped) await this._runTestOrAllHook(entry, annotations, runEntry.retry);
      }
    }

    for (const hook of suite.hooks) {
      if (hook._type !== 'afterAll') continue;
      await this._runTestOrAllHook(hook, annotations, 0);
    }
  }

  async _runTestOrAllHook(test, annotations, retry) {
    let lastStepId = 0;
    const testInfo = new _testInfo.TestInfoImpl(this._loader, this._params, test, retry, data => {
      const stepId = `${data.category}@${data.title}@${++lastStepId}`;
      let callbackHandled = false;
      const step = { ...data,
        complete: error => {
          if (callbackHandled) return;
          callbackHandled = true;
          if (error instanceof Error) error = (0, _util2.serializeError)(error);
          const payload = {
            testId: test._id,
            stepId,
            wallTime: Date.now(),
            error
          };
          this.emit('stepEnd', payload);
        }
      };
      const hasLocation = data.location && !data.location.file.includes('@playwright'); // Sanitize location that comes from user land, it might have extra properties.

      const location = data.location && hasLocation ? {
        file: data.location.file,
        line: data.location.line,
        column: data.location.column
      } : undefined;
      const payload = {
        testId: test._id,
        stepId,
        ...data,
        location,
        wallTime: Date.now()
      };
      this.emit('stepBegin', payload);
      return step;
    }); // Inherit test.setTimeout() from parent suites.

    for (let suite = test.parent; suite; suite = suite.parent) {
      if (suite._timeout !== undefined) {
        testInfo.setTimeout(suite._timeout);
        break;
      }
    } // Process annotations defined on parent suites.


    for (const annotation of annotations) {
      testInfo.annotations.push(annotation);

      switch (annotation.type) {
        case 'fixme':
        case 'skip':
          testInfo.expectedStatus = 'skipped';
          break;

        case 'fail':
          if (testInfo.expectedStatus !== 'skipped') testInfo.expectedStatus = 'failed';
          break;

        case 'slow':
          testInfo.setTimeout(testInfo.timeout * 3);
          break;
      }
    }

    this._currentTest = testInfo;
    (0, _globals.setCurrentTestInfo)(testInfo);
    this.emit('testBegin', buildTestBeginPayload(testInfo));

    if (testInfo.expectedStatus === 'skipped') {
      testInfo.status = 'skipped';
      this.emit('testEnd', buildTestEndPayload(testInfo));
      return;
    } // Update the fixture pool - it may differ between tests, but only in test-scoped fixtures.


    this._fixtureRunner.setPool(test._pool);

    await testInfo._runWithTimeout(() => this._runTestWithBeforeHooks(test, testInfo));

    if (testInfo.status === 'timedOut') {
      // A timed-out test gets a full additional timeout to run after hooks.
      testInfo._timeoutRunner.resetTimeout(testInfo.timeout);
    }

    await testInfo._runWithTimeout(() => this._runAfterHooks(test, testInfo));
    this._currentTest = null;
    (0, _globals.setCurrentTestInfo)(null);
    const isFailure = testInfo.status !== 'skipped' && testInfo.status !== testInfo.expectedStatus;

    if (isFailure) {
      // Delay reporting testEnd result until after teardownScopes is done.
      this._failedTest = testInfo;

      if (test._type !== 'test') {
        // beforeAll/afterAll hook failure skips any remaining tests in the worker.
        if (!this._fatalError) this._fatalError = testInfo.error; // Keep any error we have, and add "timeout" message.

        if (testInfo.status === 'timedOut') this._fatalError = (0, _util2.prependToTestError)(this._fatalError, _safe.default.red(`Timeout of ${testInfo.timeout}ms exceeded in ${test._type} hook.\n`), test.location);
      }

      this.stop();
    } else {
      this.emit('testEnd', buildTestEndPayload(testInfo));
    }

    const preserveOutput = this._loader.fullConfig().preserveOutput === 'always' || this._loader.fullConfig().preserveOutput === 'failures-only' && isFailure;
    if (!preserveOutput) await removeFolderAsync(testInfo.outputDir).catch(e => {});
  }

  async _runTestWithBeforeHooks(test, testInfo) {
    const step = testInfo._addStep({
      category: 'hook',
      title: 'Before Hooks',
      canHaveChildren: true,
      forceNoParent: true
    });

    const maybeError = await testInfo._runFn(async () => {
      if (test._type === 'test') {
        const beforeEachModifiers = [];

        for (let s = test.parent; s; s = s.parent) {
          const modifiers = s._modifiers.filter(modifier => !this._fixtureRunner.dependsOnWorkerFixturesOnly(modifier.fn, modifier.location));

          beforeEachModifiers.push(...modifiers.reverse());
        }

        beforeEachModifiers.reverse();

        for (const modifier of beforeEachModifiers) {
          const result = await this._fixtureRunner.resolveParametersAndRunFunction(modifier.fn, this._workerInfo, testInfo);
          testInfo[modifier.type](!!result, modifier.description);
        }

        await this._runHooks(test.parent, 'beforeEach', testInfo);
      }

      const params = await this._fixtureRunner.resolveParametersForFunction(test.fn, this._workerInfo, testInfo);
      step.complete(); // Report fixture hooks step as completed.

      const fn = test.fn; // Extract a variable to get a better stack trace ("myTest" vs "TestCase.myTest [as fn]").

      await fn(params, testInfo);
    }, 'allowSkips');
    step.complete(maybeError); // Second complete is a no-op.
  }

  async _runAfterHooks(test, testInfo) {
    const step = testInfo._addStep({
      category: 'hook',
      title: 'After Hooks',
      canHaveChildren: true,
      forceNoParent: true
    });

    let teardownError1;
    if (test._type === 'test') teardownError1 = await testInfo._runFn(() => this._runHooks(test.parent, 'afterEach', testInfo)); // Continue teardown even after the failure.

    const teardownError2 = await testInfo._runFn(() => this._fixtureRunner.teardownScope('test'));
    step.complete(teardownError1 || teardownError2);
  }

  async _runHooks(suite, type, testInfo) {
    const all = [];

    for (let s = suite; s; s = s.parent) {
      const funcs = s._eachHooks.filter(e => e.type === type).map(e => e.fn);

      all.push(...funcs.reverse());
    }

    if (type === 'beforeEach') all.reverse();
    let error;

    for (const hook of all) {
      try {
        await this._fixtureRunner.resolveParametersAndRunFunction(hook, this._workerInfo, testInfo);
      } catch (e) {
        // Always run all the hooks, and capture the first error.
        error = error || e;
      }
    }

    if (error) throw error;
  }

  _reportDone() {
    const donePayload = {
      fatalError: this._fatalError
    };
    this.emit('done', donePayload);
    this._fatalError = undefined;
    this._failedTest = undefined;
  }

}

exports.WorkerRunner = WorkerRunner;

function buildTestBeginPayload(testInfo) {
  return {
    testId: testInfo._test._id,
    startWallTime: testInfo._startWallTime
  };
}

function buildTestEndPayload(testInfo) {
  return {
    testId: testInfo._test._id,
    duration: testInfo.duration,
    status: testInfo.status,
    errors: testInfo.errors,
    expectedStatus: testInfo.expectedStatus,
    annotations: testInfo.annotations,
    timeout: testInfo.timeout,
    attachments: testInfo.attachments.map(a => {
      var _a$body;

      return {
        name: a.name,
        contentType: a.contentType,
        path: a.path,
        body: (_a$body = a.body) === null || _a$body === void 0 ? void 0 : _a$body.toString('base64')
      };
    })
  };
}