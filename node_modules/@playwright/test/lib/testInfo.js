"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TestInfoImpl = void 0;

var _fs = _interopRequireDefault(require("fs"));

var mime = _interopRequireWildcard(require("mime"));

var _path = _interopRequireDefault(require("path"));

var _async = require("playwright-core/lib/utils/async");

var _utils = require("playwright-core/lib/utils/utils");

var _util = require("./util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TestInfoImpl {
  // ------------ TestInfo fields ------------
  get error() {
    return this.errors.length > 0 ? this.errors[0] : undefined;
  }

  set error(e) {
    if (e === undefined) throw new Error('Cannot assign testInfo.error undefined value!');
    if (!this.errors.length) this.errors.push(e);else this.errors[0] = e;
  }

  constructor(loader, workerParams, test, retry, addStepImpl) {
    this._projectImpl = void 0;
    this._addStepImpl = void 0;
    this._test = void 0;
    this._timeoutRunner = void 0;
    this._startTime = void 0;
    this._startWallTime = void 0;
    this._hasHardError = false;
    this.repeatEachIndex = void 0;
    this.retry = void 0;
    this.workerIndex = void 0;
    this.parallelIndex = void 0;
    this.project = void 0;
    this.config = void 0;
    this.title = void 0;
    this.titlePath = void 0;
    this.file = void 0;
    this.line = void 0;
    this.column = void 0;
    this.fn = void 0;
    this.expectedStatus = void 0;
    this.duration = 0;
    this.annotations = [];
    this.attachments = [];
    this.status = 'passed';
    this.stdout = [];
    this.stderr = [];
    this.timeout = void 0;
    this.snapshotSuffix = '';
    this.outputDir = void 0;
    this.snapshotDir = void 0;
    this.errors = [];
    this._projectImpl = loader.projects()[workerParams.projectIndex];
    this._test = test;
    this._addStepImpl = addStepImpl;
    this._startTime = (0, _util.monotonicTime)();
    this._startWallTime = Date.now();
    this.repeatEachIndex = workerParams.repeatEachIndex;
    this.retry = retry;
    this.workerIndex = workerParams.workerIndex;
    this.parallelIndex = workerParams.parallelIndex;
    this.project = this._projectImpl.config;
    this.config = loader.fullConfig();
    this.title = test.title;
    this.titlePath = test.titlePath();
    this.file = test.location.file;
    this.line = test.location.line;
    this.column = test.location.column;
    this.fn = test.fn;
    this.expectedStatus = test.expectedStatus;
    this.timeout = this.project.timeout;
    this._timeoutRunner = new _async.TimeoutRunner(this.timeout);

    this.outputDir = (() => {
      const sameName = loader.projects().filter(project => project.config.name === this.project.name);
      let uniqueProjectNamePathSegment;
      if (sameName.length > 1) uniqueProjectNamePathSegment = this.project.name + (sameName.indexOf(this._projectImpl) + 1);else uniqueProjectNamePathSegment = this.project.name;

      const relativeTestFilePath = _path.default.relative(this.project.testDir, test._requireFile.replace(/\.(spec|test)\.(js|ts|mjs)$/, ''));

      const sanitizedRelativePath = relativeTestFilePath.replace(process.platform === 'win32' ? new RegExp('\\\\', 'g') : new RegExp('/', 'g'), '-');
      const fullTitleWithoutSpec = test.titlePath().slice(1).join(' ') + (test._type === 'test' ? '' : '-worker' + this.workerIndex);
      let testOutputDir = sanitizedRelativePath + '-' + (0, _util.sanitizeForFilePath)((0, _util.trimLongString)(fullTitleWithoutSpec));
      if (uniqueProjectNamePathSegment) testOutputDir += '-' + (0, _util.sanitizeForFilePath)(uniqueProjectNamePathSegment);
      if (this.retry) testOutputDir += '-retry' + this.retry;
      if (this.repeatEachIndex) testOutputDir += '-repeat' + this.repeatEachIndex;
      return _path.default.join(this.project.outputDir, testOutputDir);
    })();

    this.snapshotDir = (() => {
      const relativeTestFilePath = _path.default.relative(this.project.testDir, test._requireFile);

      return _path.default.join(this.project.snapshotDir, relativeTestFilePath + '-snapshots');
    })();
  }

  _modifier(type, modifierArgs) {
    if (typeof modifierArgs[1] === 'function') {
      throw new Error(['It looks like you are calling test.skip() inside the test and pass a callback.', 'Pass a condition instead and optional description instead:', `test('my test', async ({ page, isMobile }) => {`, `  test.skip(isMobile, 'This test is not applicable on mobile');`, `});`].join('\n'));
    }

    if (modifierArgs.length >= 1 && !modifierArgs[0]) return;
    const description = modifierArgs[1];
    this.annotations.push({
      type,
      description
    });

    if (type === 'slow') {
      this.setTimeout(this.timeout * 3);
    } else if (type === 'skip' || type === 'fixme') {
      this.expectedStatus = 'skipped';
      throw new SkipError('Test is skipped: ' + (description || ''));
    } else if (type === 'fail') {
      if (this.expectedStatus !== 'skipped') this.expectedStatus = 'failed';
    }
  }

  async _runWithTimeout(cb) {
    try {
      await this._timeoutRunner.run(cb);
    } catch (error) {
      if (!(error instanceof _async.TimeoutRunnerError)) throw error; // Do not overwrite existing failure upon hook/teardown timeout.

      if (this.status === 'passed') this.status = 'timedOut';
    }

    this.duration = (0, _util.monotonicTime)() - this._startTime;
  }

  async _runFn(fn, skips) {
    try {
      await fn();
    } catch (error) {
      if (skips === 'allowSkips' && error instanceof SkipError) {
        if (this.status === 'passed') this.status = 'skipped';
      } else {
        const serialized = (0, _util.serializeError)(error);

        this._failWithError(serialized, true
        /* isHardError */
        );

        return serialized;
      }
    }
  }

  _addStep(data) {
    return this._addStepImpl(data);
  }

  _failWithError(error, isHardError) {
    // Do not overwrite any previous hard errors.
    // Some (but not all) scenarios include:
    //   - expect() that fails after uncaught exception.
    //   - fail after the timeout, e.g. due to fixture teardown.
    if (isHardError && this._hasHardError) return;
    if (isHardError) this._hasHardError = true;
    if (this.status === 'passed') this.status = 'failed';
    this.errors.push(error);
  } // ------------ TestInfo methods ------------


  async attach(name, options = {}) {
    if ((options.path !== undefined ? 1 : 0) + (options.body !== undefined ? 1 : 0) !== 1) throw new Error(`Exactly one of "path" and "body" must be specified`);

    if (options.path !== undefined) {
      var _options$contentType;

      const hash = (0, _utils.calculateSha1)(options.path);
      const dest = this.outputPath('attachments', hash + _path.default.extname(options.path));
      await _fs.default.promises.mkdir(_path.default.dirname(dest), {
        recursive: true
      });
      await _fs.default.promises.copyFile(options.path, dest);
      const contentType = (_options$contentType = options.contentType) !== null && _options$contentType !== void 0 ? _options$contentType : mime.getType(_path.default.basename(options.path)) || 'application/octet-stream';
      this.attachments.push({
        name,
        contentType,
        path: dest
      });
    } else {
      var _options$contentType2;

      const contentType = (_options$contentType2 = options.contentType) !== null && _options$contentType2 !== void 0 ? _options$contentType2 : typeof options.body === 'string' ? 'text/plain' : 'application/octet-stream';
      this.attachments.push({
        name,
        contentType,
        body: typeof options.body === 'string' ? Buffer.from(options.body) : options.body
      });
    }
  }

  outputPath(...pathSegments) {
    _fs.default.mkdirSync(this.outputDir, {
      recursive: true
    });

    const joinedPath = _path.default.join(...pathSegments);

    const outputPath = (0, _util.getContainedPath)(this.outputDir, joinedPath);
    if (outputPath) return outputPath;
    throw new Error(`The outputPath is not allowed outside of the parent directory. Please fix the defined path.\n\n\toutputPath: ${joinedPath}`);
  }

  snapshotPath(...pathSegments) {
    let suffix = '';
    const projectNamePathSegment = (0, _util.sanitizeForFilePath)(this.project.name);
    if (projectNamePathSegment) suffix += '-' + projectNamePathSegment;
    if (this.snapshotSuffix) suffix += '-' + this.snapshotSuffix;
    const subPath = (0, _util.addSuffixToFilePath)(_path.default.join(...pathSegments), suffix);
    const snapshotPath = (0, _util.getContainedPath)(this.snapshotDir, subPath);
    if (snapshotPath) return snapshotPath;
    throw new Error(`The snapshotPath is not allowed outside of the parent directory. Please fix the defined path.\n\n\tsnapshotPath: ${subPath}`);
  }

  skip(...args) {
    this._modifier('skip', args);
  }

  fixme(...args) {
    this._modifier('fixme', args);
  }

  fail(...args) {
    this._modifier('fail', args);
  }

  slow(...args) {
    this._modifier('slow', args);
  }

  setTimeout(timeout) {
    if (!this.timeout) return; // Zero timeout means some debug mode - do not set a timeout.

    this.timeout = timeout;

    this._timeoutRunner.updateTimeout(timeout);
  }

}

exports.TestInfoImpl = TestInfoImpl;

class SkipError extends Error {}